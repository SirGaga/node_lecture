/**
 * Node本身能够做到如此高性能的根本原因在于事件（event）的使用，以及对于事件坚挺着（listener，callback）的调用上
 *
 * Node本身是基于事件循环机制的
 *
 * 本质上，当Node启动一个文件或者服务器后，Node实际上是运行在一个死循环当中的。
 *
 * while(true){
 *     ...
 * }
 *
 * 在这个死循环当中，Node会不断的发射事件、监听事件并且执行回掉逻辑
 *
 * 事件来源主要有两种：一是Node自身所发射的事件，二是来自于Node自身所运行的环境。
 * 监听事件：回掉都是要依附于相应的事件的。
 * 执行回调逻辑：本质上都是由底层来执行的。
 *
 * 关于IO操作的异步执行逻辑：
 * 1.同步模式：
 * 2.异步模式：poll、epoll、IOCP（windows）
 *
 * Node的单线程：所谓单线程指的是Node的逻辑执行主线是单线程的，即JavaScript代码运行所处的线程，这个是单线程，
 * 因为JavaScript本身只能执行在单线程中。
 *
 * 当我们在程序中引入了某个第三方模块时，那么整体的全部执行逻辑如下所示：
 * Node -> 调用第三方模块  -> 原生模块的调用  -> 原生模块内部的实现 -> 调用C++模块 -> libuv -> 线程池的调用 -> 选取可用线程
 * ->执行底层的IO操作（涉及到底层操作系统的调用）
 *
 * Node在执行过程中，他会判断当前的操作系统类型；
 * Node完整的事件循环逻辑
 * 1.启动Node运行时
 * 2.监测是否有待处理的事件
 * 3.如果没有，回到循环开始
 * 4.如果有，那么从事件中取出一个事件
 * 5.判断当前这个事件有没有与之关联的事件处理器（回调）
 * 6.如果没有，回到循环开始
 * 7.如果有，则执行事件的回调逻辑
 * 8.回到循环开始，开始新一轮的事件检测流程
 *
 * 整个Node的执行过程实际上是由完整的事件循环机制 + 底层的操作系统异步IO调用 + 线程池（由底层操作系统提供）共同配合完成的
 * 对于Node主线程来说，它只能运行在一个核心上面。
 * 对于底层的线程池来说，他们却可以运行在多个核心上面，当然也可以同时运行，因此他们是完成可以利用到多核的优势的
 *
 *
 */